#!/usr/bin/env node

/**
 * Task Details Loader Module
 * 
 * Handles loading and managing task details from files:
 * - Task implementation files
 * - Task metadata
 * - Task dependencies
 * - Task documentation
 */

import fs from 'fs';
import path from 'path';

export class TaskDetailsLoader {
    constructor(config, log) {
        this.config = config;
        this.log = log;
        this.tasksDir = config.tasksDir;
    }

    async loadTaskDetails(task) {
        this.log(`üìÇ Loading task details for: ${task.name}`);
        
        const taskDir = this.getTaskDirectory(task);
        const implementationFile = this.getImplementationFilePath(task);
        
        try {
            // Load implementation file if it exists
            let implementationContent = '';
            if (fs.existsSync(implementationFile)) {
                implementationContent = fs.readFileSync(implementationFile, 'utf8');
                this.log(`‚úÖ Loaded implementation file: ${implementationFile}`);
            } else {
                this.log(`‚ö†Ô∏è Implementation file not found: ${implementationFile}`, 'WARNING');
                implementationContent = this.generateDefaultTaskContent(task);
            }

            // Load additional task files
            const taskDetails = {
                id: task.id,
                name: task.name,
                category: task.category,
                time: task.time,
                status: task.status,
                dependencies: task.dependencies,
                implementation: implementationContent,
                metadata: await this.loadTaskMetadata(taskDir),
                documentation: await this.loadTaskDocumentation(taskDir),
                requirements: await this.loadTaskRequirements(taskDir)
            };

            this.log(`‚úÖ Task details loaded successfully for: ${task.name}`);
            return taskDetails;
            
        } catch (error) {
            this.log(`‚ùå Error loading task details: ${error.message}`, 'ERROR');
            return this.generateFallbackTaskDetails(task);
        }
    }

    getTaskDirectory(task) {
        return path.join(
            this.tasksDir,
            task.category.replace(/\s+/g, '-').toLowerCase(),
            task.name.replace(/\s+/g, '-').toLowerCase()
        );
    }

    getImplementationFilePath(task) {
        const taskDir = this.getTaskDirectory(task);
        return path.join(taskDir, `${task.name.replace(/\s+/g, '-').toLowerCase()}-implementation.md`);
    }

    generateDefaultTaskContent(task) {
        return `# Task: ${task.name}

## Category: ${task.category}
## Time Estimate: ${task.time}
## Status: ${task.status}

## Task Description
[TO BE FILLED - Describe what this task involves]

## Requirements
- [ ] Requirement 1
- [ ] Requirement 2
- [ ] Requirement 3

## Implementation Steps
1. Step 1
2. Step 2
3. Step 3

## Dependencies
${task.dependencies || 'None'}

## Notes
[Additional notes and considerations]

---
*Generated by Task Details Loader*`;
    }

    generateFallbackTaskDetails(task) {
        return {
            id: task.id,
            name: task.name,
            category: task.category,
            time: task.time,
            status: task.status,
            dependencies: task.dependencies,
            implementation: this.generateDefaultTaskContent(task),
            metadata: {},
            documentation: '',
            requirements: []
        };
    }

    async loadTaskMetadata(taskDir) {
        const metadataFile = path.join(taskDir, 'metadata.json');
        
        try {
            if (fs.existsSync(metadataFile)) {
                const content = fs.readFileSync(metadataFile, 'utf8');
                return JSON.parse(content);
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Error loading task metadata: ${error.message}`, 'WARNING');
        }
        
        return {};
    }

    async loadTaskDocumentation(taskDir) {
        const docFiles = [
            'documentation.md',
            'README.md',
            'notes.md'
        ];

        for (const docFile of docFiles) {
            const docPath = path.join(taskDir, docFile);
            if (fs.existsSync(docPath)) {
                try {
                    const content = fs.readFileSync(docPath, 'utf8');
                    this.log(`‚úÖ Loaded documentation: ${docFile}`);
                    return content;
                } catch (error) {
                    this.log(`‚ö†Ô∏è Error loading documentation ${docFile}: ${error.message}`, 'WARNING');
                }
            }
        }
        
        return '';
    }

    async loadTaskRequirements(taskDir) {
        const requirementsFile = path.join(taskDir, 'requirements.md');
        
        try {
            if (fs.existsSync(requirementsFile)) {
                const content = fs.readFileSync(requirementsFile, 'utf8');
                return this.parseRequirements(content);
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Error loading task requirements: ${error.message}`, 'WARNING');
        }
        
        return [];
    }

    parseRequirements(content) {
        const requirements = [];
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('- [ ]') || trimmed.startsWith('* [ ]')) {
                const requirement = trimmed.replace(/^[-*]\s*\[ \]\s*/, '').trim();
                if (requirement) {
                    requirements.push(requirement);
                }
            }
        }
        
        return requirements;
    }

    async saveTaskDetails(task, details) {
        const taskDir = this.getTaskDirectory(task);
        
        try {
            // Ensure task directory exists
            if (!fs.existsSync(taskDir)) {
                fs.mkdirSync(taskDir, { recursive: true });
                this.log(`üìÅ Created task directory: ${taskDir}`);
            }

            // Save implementation file
            const implementationFile = this.getImplementationFilePath(task);
            fs.writeFileSync(implementationFile, details.implementation);
            this.log(`üíæ Saved implementation file: ${implementationFile}`);

            // Save metadata
            if (details.metadata && Object.keys(details.metadata).length > 0) {
                const metadataFile = path.join(taskDir, 'metadata.json');
                fs.writeFileSync(metadataFile, JSON.stringify(details.metadata, null, 2));
                this.log(`üíæ Saved metadata file: ${metadataFile}`);
            }

            // Save documentation
            if (details.documentation) {
                const docFile = path.join(taskDir, 'documentation.md');
                fs.writeFileSync(docFile, details.documentation);
                this.log(`üíæ Saved documentation file: ${docFile}`);
            }

            // Save requirements
            if (details.requirements && details.requirements.length > 0) {
                const requirementsContent = details.requirements.map(req => `- [ ] ${req}`).join('\n');
                const requirementsFile = path.join(taskDir, 'requirements.md');
                fs.writeFileSync(requirementsFile, requirementsContent);
                this.log(`üíæ Saved requirements file: ${requirementsFile}`);
            }

            this.log(`‚úÖ Task details saved successfully for: ${task.name}`);
            
        } catch (error) {
            this.log(`‚ùå Error saving task details: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    async listTaskFiles(task) {
        const taskDir = this.getTaskDirectory(task);
        const files = [];

        try {
            if (fs.existsSync(taskDir)) {
                const items = fs.readdirSync(taskDir);
                
                for (const item of items) {
                    const itemPath = path.join(taskDir, item);
                    const stats = fs.statSync(itemPath);
                    
                    files.push({
                        name: item,
                        path: itemPath,
                        isDirectory: stats.isDirectory(),
                        size: stats.size,
                        modified: stats.mtime
                    });
                }
            }
        } catch (error) {
            this.log(`‚ùå Error listing task files: ${error.message}`, 'ERROR');
        }

        return files;
    }

    async validateTaskStructure(task) {
        const taskDir = this.getTaskDirectory(task);
        const issues = [];

        try {
            // Check if task directory exists
            if (!fs.existsSync(taskDir)) {
                issues.push(`Task directory does not exist: ${taskDir}`);
                return { valid: false, issues };
            }

            // Check for required files
            const requiredFiles = [
                `${task.name.replace(/\s+/g, '-').toLowerCase()}-implementation.md`
            ];

            for (const file of requiredFiles) {
                const filePath = path.join(taskDir, file);
                if (!fs.existsSync(filePath)) {
                    issues.push(`Required file missing: ${file}`);
                }
            }

            // Check for optional but recommended files
            const recommendedFiles = [
                'documentation.md',
                'requirements.md',
                'metadata.json'
            ];

            for (const file of recommendedFiles) {
                const filePath = path.join(taskDir, file);
                if (!fs.existsSync(filePath)) {
                    issues.push(`Recommended file missing: ${file}`);
                }
            }

            return {
                valid: issues.length === 0,
                issues,
                taskDir
            };

        } catch (error) {
            issues.push(`Error validating task structure: ${error.message}`);
            return { valid: false, issues };
        }
    }

    async createTaskTemplate(task) {
        this.log(`üìã Creating task template for: ${task.name}`);
        
        const taskDir = this.getTaskDirectory(task);
        
        try {
            // Create task directory
            if (!fs.existsSync(taskDir)) {
                fs.mkdirSync(taskDir, { recursive: true });
                this.log(`üìÅ Created task directory: ${taskDir}`);
            }

            // Create implementation file
            const implementationContent = this.generateDefaultTaskContent(task);
            const implementationFile = this.getImplementationFilePath(task);
            fs.writeFileSync(implementationFile, implementationContent);
            this.log(`üìù Created implementation file: ${implementationFile}`);

            // Create documentation file
            const docContent = `# Documentation for ${task.name}

## Overview
[Describe the task and its purpose]

## Technical Details
[Technical implementation details]

## Notes
[Additional notes and considerations]

---
*Generated by Task Details Loader*`;

            const docFile = path.join(taskDir, 'documentation.md');
            fs.writeFileSync(docFile, docContent);
            this.log(`üìù Created documentation file: ${docFile}`);

            // Create requirements file
            const requirementsContent = `# Requirements for ${task.name}

## Functional Requirements
- [ ] Requirement 1
- [ ] Requirement 2
- [ ] Requirement 3

## Non-Functional Requirements
- [ ] Performance requirement
- [ ] Security requirement
- [ ] Usability requirement

---
*Generated by Task Details Loader*`;

            const requirementsFile = path.join(taskDir, 'requirements.md');
            fs.writeFileSync(requirementsFile, requirementsContent);
            this.log(`üìù Created requirements file: ${requirementsFile}`);

            // Create metadata file
            const metadata = {
                taskId: task.id,
                taskName: task.name,
                category: task.category,
                timeEstimate: task.time,
                status: task.status,
                dependencies: task.dependencies,
                created: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };

            const metadataFile = path.join(taskDir, 'metadata.json');
            fs.writeFileSync(metadataFile, JSON.stringify(metadata, null, 2));
            this.log(`üìù Created metadata file: ${metadataFile}`);

            this.log(`‚úÖ Task template created successfully for: ${task.name}`);
            return taskDir;

        } catch (error) {
            this.log(`‚ùå Error creating task template: ${error.message}`, 'ERROR');
            throw error;
        }
    }
}

export default TaskDetailsLoader; 